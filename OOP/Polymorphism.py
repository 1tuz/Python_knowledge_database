class Shape:
    def area(self):
        pass


class Square(Shape):
    def __init__(self, side_length):
        self.side_length = side_length

    def area(self):
        return self.side_length ** 2


class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2


shapes = [Square(5), Circle(2), Square(3), Circle(4)]
for shape in shapes:
    print(shape.area())



# В этом примере у нас есть базовый класс Shape, который определяет area метод, но не предоставляет реализацию. Затем
# у нас есть два подкласса Square, Circleкоторые расширяют Shape и предоставляют собственную реализацию area метода.
#
# Наконец, мы создаем список фигур, содержащих экземпляры обоих Squareи Circle, и перебираем список,
# вызывая areaметод для каждой фигуры. Это демонстрирует полиморфизм, поскольку разные объекты реагируют на вызов
# одного и того же метода по-разному, в зависимости от их фактического типа.
#
# Обратите внимание, что в этом примере
# areaметод вызывается для каждого объекта в списке, независимо от его фактического типа, а правильная реализация
# метода вызывается автоматически в зависимости от типа объекта, что является ключевым аспектом полиморфизма в
# объекте. ориентированное программирование.